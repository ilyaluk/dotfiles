if [[ -n "$ZPROF" ]]; then
    zmodload zsh/zprof
fi

source ~/.profile

# enable zsh completion
fpath=(
    $HOME/.zsh/functions
    $fpath
)

export XDG_DATA_DIRS="/usr/local/share:/usr/share:/var/lib/flatpak/exports/share:/home/ilya/.local/share/flatpak/exports/share"

# activate mise for all mise-managed binaries
# TODO: this command takes ~20ms, look into ways to source from file
#source <(mise activate)

# ================================================
# Apps config
export GIT_TERMINAL_PROMPT=1
export LESS="RSXF"
export TG_FETCH_DEPENDENCY_OUTPUT_FROM_STATE=true
export LIMA_SHELL=zsh

# disable auto-title from grml-zsh-config
export NOTITLE=1

# ================================================
# Includes
source ~/.zsh/grml_rc

source /usr/share/doc/fzf/examples/key-bindings.zsh
source /usr/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
# ================================================
# Shell stuff
export CDPATH=.:~/fb:~/fun
export EDITOR=nvim

HISTFILE=~/.histfile
HISTSIZE=100000000
SAVEHIST=100000000
setopt appendhistory autocd extendedglob
unsetopt completealiases

# Stop Ctrl+W on / and .
autoload -U select-word-style
select-word-style bash
WORDCHARS='*?_-[]~=&;!#$%^(){}<>'

function prompt_venv () {
    REPLY=${VIRTUAL_ENV+ðŸ${VIRTUAL_ENV:t} }
}
grml_theme_add_token venv -f prompt_venv '%F{green}' '%f'

function prompt_aws_profile () {
    REPLY=${AWS_PROFILE+ðŸ§±${AWS_PROFILE:t} }
}
grml_theme_add_token aws_profile -f prompt_aws_profile '%F{red}' '%f'

function prompt_kube_ctx () {
    REPLY=""
    [[ ! -f ~/.kube/config ]] && return
    # it's faster by couple of dozen of ms than kubectl config current-context
    ctx=$(grep current-context ~/.kube/config | cut -d' ' -f2)
    if [[ -n "$ctx" ]]; then
        REPLY="â˜¸ ${ctx:t} "
    fi
}
grml_theme_add_token kube_ctx -f prompt_kube_ctx '%F{magenta}' '%f'

zstyle ':vcs_info:*' enable jj git svn
# expand to "misc" template for jj backend, see .zsh/functions/VCS_INFO_get_data_jj
zstyle ':vcs_info:jj:*' formats '[%m] '
zstyle ':vcs_info:jj:*' actionformats '[%m] '

ZSH_HIGHLIGHT_STYLES[comment]=fg=blue
zstyle :compinstall filename "$USER/.zshrc"
zstyle ':prompt:grml:right:setup' items ''
zstyle ':prompt:grml:left:setup' items venv aws_profile kube_ctx user at host path vcs rc percent

autoload -z edit-command-line
zle -N edit-command-line
bindkey "^X^E" edit-command-line

bindkey "^[[1;5C" forward-word
bindkey "^[[1;1C" forward-word
bindkey "^[[1;1D" backward-word
bindkey "^[[1;9C" forward-word
bindkey "^[[1;9D" backward-word

# autoload -U +X bashcompinit && bashcompinit
# autoload -U compinit && compinit

# ================================================
# misc autocompletes
source ~/.zsh/mise_completion
source ~/.zsh/atuin
source ~/.zsh/jj
source ~/.zsh/tailscale
source ~/.zsh/rc

# ================================================
# Title setting
function my_precmd_xterm_title() {
    # shorten path elements if too long
    # e.g. ~/wrk/long/project/path/aaa/bbb -> ~/w/l/p/path/aaa/bbb
    local wd="${(%):-"%~"}"
    if (( $(echo "$wd" | tr -cd '/' | wc -c) > 3 )); then
    wd="$(echo "$wd" | awk -F'/' '{
            for (i=1; i<=NF-3; i++) $i=substr($i, 1, 1);
            print
        }' OFS="/")"
    fi
    set_title "$wd"
}

function my_preexec_xterm_title() {
    # set title to command being executed with ! prefix
    # e.g. !htop
    set_title "${(%):-""}!$2"
}

case $TERM in
    (xterm*|rxvt*)
        add-zsh-hook precmd my_precmd_xterm_title
        add-zsh-hook preexec my_preexec_xterm_title
        ;;
esac


# ================================================
# Aliases / functions
alias -- -='cd -'

alias py=python3
alias python=python3
alias ipy=python3
alias vim=nvim
alias diff=colordiff
alias tf=terraform
alias tfi='terraform init'
alias tfp='terraform plan'
alias tfa='terraform apply'
alias tgi='terragrunt init'
alias tgp='terragrunt plan'
alias tga='terragrunt apply'
alias tg=terragrunt
alias k=kubectl

alias b64='base64'
alias b64d='base64 -d'
function b64dcp () { echo $1 | base64 -d | pbcopy }
function len() { echo ${#1} }
alias hd='hexdump -C'
alias sus='sort | uniq -c | sort'

alias awsp='export AWS_PROFILE=$(cat ~/.aws/config | grep "^\[profile" | cut -d" " -f2- | tr -d "\]" | fzf)'
alias awsup='unset AWS_PROFILE'
alias awsl='aws sso login'

alias ghprv='gh pr view --web $(jj bookmark list -r "heads(::@- & bookmarks())" -T name)'

alias j=jj
alias jl='jj log'
alias jn='jj next || jj new'
alias jp='jj prev'
alias je='jj edit'
alias js='jj squash'
alias jz='jj z'
alias jza='jj za'
alias jzt='jj zt'
alias jsp='jj squash && jj git push'
alias jgp='jj git push'
alias jgf='jj git fetch'
alias jbm='jj tug'
alias jbmp='jj tug && jj git push'
alias ju='jjui'

function jm() {
    bookmark=master
    if [[ -n $(jj bookmark list main) ]]; then bookmark=main; fi
    jj git fetch
    jj new $bookmark
}

function llm_desc() {
    local change_ref="${1:-@}"
    (jj show --stat "$change_ref"; jj diff --git -r "$change_ref") | \
        llm -m claude-4-sonnet -s 'Generate git commit title and description based on provided change description and git-formatted diff. Include ticket number if it is present in the input. Use existing text desctiption (if provided) as a arefernce. Be succint. Describe changes as list, prepend each item with "- ". Output _only_ title, newline, message.' | \
        jj desc --stdin "$change_ref"
    # edit manually right after
    jj desc "$change_ref"
}

function newpr() {
    change_id=$1
    if [[ -z $change_id ]]; then
        if [ $(jj show @ -T empty --no-patch) = false ]; then
            jj commit
        fi
        change_id="@-"
    fi
    base=$(jj log -r "latest(::(${change_id}-) & bookmarks())" -T bookmarks --no-graph | cut -d' ' -f1)
    branch=$(jj log -r "${change_id} & bookmarks()" -T bookmarks --no-graph)
    if [[ -z "$branch" ]]; then
        echo "Generating suggested branch name..."
        suggest=$(jj log -r "${base}..@" --patch | \
            llm -m claude-4-sonnet -s 'Generate a short git branch name based on the log and patches. Use following format: "{user}/{ticket-}{name}". User should be short name. If none of commits have ticket refence, dont include it. Output _only_ branch name.')
        echo "Enter branch name. Empty to auto-generate. LLM suggested: $suggest"
        read branch
        [[ -n "$branch" ]] && jj bookmark create "$branch" -r "$change_id"
    fi
    if [[ -n "$branch" ]]; then
        jj git push -b "$branch" --allow-new
    else
        jj git push -c "$change_id"
    fi
    head=$(jj log -r "$change_id" -T bookmarks --no-graph)
    gh pr create -H $head -B $base
    ghprv
}

# use zed binary, not zsh function
unfunction zed

alias dquilt="quilt --quiltrc=${HOME}/.quiltrc-dpkg"

# ================================================
# Expand .... to ../../.. in the command line
function expand-dots() {
    local MATCH
    if [[ $LBUFFER =~ '\.\.\.+' && ! $LBUFFER =~ '^.*go ' ]]; then
        LBUFFER=$LBUFFER:fs%\.\.\.%../..%
    fi
}

function expand-dots-then-expand-or-complete() {
    zle expand-dots
    zle expand-or-complete
}

function expand-dots-then-accept-line() {
    zle expand-dots
    zle accept-line
}

zle -N expand-dots
zle -N expand-dots-then-expand-or-complete
zle -N expand-dots-then-accept-line
bindkey '^I' expand-dots-then-expand-or-complete
bindkey '^M' expand-dots-then-accept-line

if ! pgrep ssh-agent > /dev/null; then
    ssh-agent -t 12h > "$XDG_RUNTIME_DIR/ssh-agent.env"
fi
if [ ! -f "$SSH_AUTH_SOCK" ]; then
    source "$XDG_RUNTIME_DIR/ssh-agent.env" >/dev/null
fi

if [ -z "$(ssh-add -l 2>/dev/null | grep -v 'The agent has no identities')" ]; then
    echo "ssh agent has no identities, adding all keys from ~/.ssh/"
    for key in ~/.ssh/id_*; do
        [[ "$key" == *.pub ]] && continue
        [[ -f "$key" ]] && ssh-add "$key" 2>/dev/null
    done
fi

if [[ -n "$ZPROF" ]]; then
    zprof
fi
